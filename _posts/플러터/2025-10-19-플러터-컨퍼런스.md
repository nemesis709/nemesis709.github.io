---
layout: post
title: "플러터 컨퍼런스 2025 세션 정리"
author: "Jin"
tags: Flutter AI Animation
---

# 플러터 컨퍼런스 2025 세션 정리

플러터 컨퍼런스에서 발표된 주요 세션들을 정리한다.

## 세션 1: 온디바이스 AI 활용하기

### 온디바이스 AI란?

온디바이스 AI는 클라우드 서버가 아닌 사용자의 디바이스에서 직접 AI 모델을 실행하는 기술이다. 이를 통해 다음과 같은 장점을 얻을 수 있다:

- **개인정보 보호**: 데이터가 디바이스를 벗어나지 않음
- **빠른 응답 속도**: 네트워크 지연 없음
- **오프라인 동작**: 인터넷 연결 없이도 사용 가능
- **비용 절감**: 서버 비용 없음

### 온디바이스 AI의 3대 핵심 구성 요소

1. **모델 (Model)**: AI 알고리즘과 학습된 가중치
2. **하드웨어 (Hardware)**: CPU, GPU, NPU 등 연산 장치
3. **추론/런타임 (Inference/Runtime)**: 모델을 실행하는 소프트웨어 환경

### 주요 플랫폼 및 도구

#### Ollama
Llama 2, Llama 3, Phi, Mistral, Solar와 같은 대규모 언어 모델(LLM)을 로컬 환경에서 실행할 수 있는 오픈소스 프레임워크

#### 플랫폼별 AI SDK
- **Google AI Edge SDK**: 구글의 온디바이스 AI 솔루션
- **Gemini Nano**: 구글의 경량화된 AI 모델
- **AFM (Apple Foundation Model)**: 애플의 파운데이션 모델

### 플러터에서 온디바이스 AI 구현 과정

#### 1. 패키지 선택
플러터에서 온디바이스 AI를 구현하기 위한 주요 패키지들:
- `flutter_gemma`: 구글 Gemma 모델 지원
- `cactus`: 다양한 AI 모델 지원
- `tflite_flutter`: TensorFlow Lite 지원

#### 2. 모델 다운로드
선택한 AI 모델을 디바이스에 다운로드하고 로컬에 저장한다.

#### 3. 모델 초기화 및 실행
다운로드된 모델을 메모리에 로드하고 추론을 실행한다.

---

## 세션 2: AnimatedTo - 움직이는 애니메이션의 변화

### 암시적/명시적 애니메이션이란?

플러터에서 애니메이션은 크게 두 가지로 나뉜다:

- **암시적 애니메이션 (Implicit Animation)**: 자동으로 처리되는 간단한 애니메이션
- **명시적 애니메이션 (Explicit Animation)**: 컨트롤러를 정의하고 시작/정지 시점을 직접 제어하는 복잡한 애니메이션

### 위치 기반 애니메이션의 문제점

특정 위치까지 애니메이션을 이동시키려면 몇 픽셀이 필요한지 알아야 한다. 하지만 화면 크기마다 다르기 때문에 하드코딩할 수 없다.

### 기존 해결 방법들

#### 1. RenderObject를 이용한 위치 감지

플러터의 렌더링 구조를 활용하여 위치를 계산할 수 있다:

```
Widget → Element → RenderObject
```

```dart
final context = _key.currentContext;
final renderObject = context?.findRenderObject();
final position = renderObject.localToGlobal(Offset.zero);
final height = position.dy;
```

**GlobalKey의 역할**: GlobalKey는 Element와 RenderObject를 캐시하고 재사용할 수 있게 해준다. 이를 통해 위젯 트리가 재구성되어도 동일한 Element와 RenderObject에 접근할 수 있다.

#### 2. 더미 위젯 활용

투명한 더미 위젯을 생성하여 위치를 파악하는 방법도 있다.

### 기존 방법들의 한계

- **복잡한 레이아웃 계산 필요**: 매번 위치를 계산해야 함
- **추가 위젯 필요**: 더미 위젯 등 불필요한 요소 생성
- **복잡한 애니메이션에서 제한적**: 다중 요소 애니메이션에서 사용 어려움

### AnimatedTo 패키지의 해결책

AnimatedTo 패키지는 커스텀 RenderObject를 통해 이러한 문제들을 해결한다:

```
Widget → Element → Customized RenderObject
```

**주요 장점:**
- 레이아웃 계산 없는 애니메이션
- 추가적인 트릭 위젯 불필요
- 복잡한 애니메이션에서도 자연스러운 동작

**참고**: [animated_to 패키지](https://pub.dev/packages/animated_to)

---

## 결론

플러터 컨퍼런스에서 소개된 두 세션 모두 플러터 개발의 고급 기법들을 다뤘다:

1. **온디바이스 AI**: 개인정보를 보호하면서도 빠른 AI 기능을 제공하는 기술
2. **AnimatedTo**: 복잡한 위치 계산 없이 자연스러운 애니메이션을 구현하는 방법

이러한 기술들을 활용하면 더욱 향상된 사용자 경험을 제공할 수 있다.

## 세션 3: 코드 수정 없이 LLM을 백엔드 API에 연결하기

### 핵심 원칙: 특정 모델에 의존하지 않기

비즈니스 로직을 특정 LLM 모델에 종속시키면 안 된다. 모델은 언제든 변경될 수 있기 때문이다.

### LLM 교체의 어려움과 해결책

**문제**: 어떻게 쉽게 LLM을 교체할 수 있을까?

**기존 솔루션들**:
- **Open WebUI**: 다양한 LLM 지원하지만 제한적
- **OpenRouter**: 여러 모델 제공하지만 비용 발생

### Open Chat Playground

**특징**: 수많은 LLM을 통합적으로 사용할 수 있는 오픈소스 프로젝트

**GitHub**: [open-chat-playground](https://github.com/abetlen/open-chat-playground)

### 백엔드 API 활용 방법

Open Chat Playground를 백엔드 API로 활용하려면 `/api/chat/responses` 엔드포인트를 사용한다.

코드 수정 없이 다양한 LLM 모델을 교체하여 사용할 수 있다.
(커서랑 뭐가 다른거지..?)

## 세션 4: Claude Code와 Figma MCP 활용하기

### 플러터에서 Figma Dev Mode, MCP, Claude Code를 사용하는 이유

1. **Figma Dev Mode MCP의 플러터 지원**: 제한적이지만 여전히 개발 속도를 향상시킬 수 있다
2. **AI와 MCP의 역할**: 디자인과 엔지니어링 간의 격차를 해소한다
3. **네이티브 앱의 장점**: 일관된 디자인 시스템을 가지고 있어 AI 코드 생성에 최적화되어 있다
4. **Claude Code의 확산**: 많은 팀에서 채택하고 있는 추세다

### Figma 사용을 위한 전제 조건

1. **엔지니어링 관점 도입**: Figma에 개발자 시각을 적용한다
2. **AI UI 코드 생성을 위한 디자인**: UI와 비즈니스 로직을 분리한다

### 효과적인 Figma 활용 방법

#### 필수 요소들
- **변수 활용**: 컬러 등을 변수로 정의한다
- **주석 추가**: 화면 전환 등에 대한 Figma 주석을 작성한다
- **컴포넌트 생성**: 재사용 가능한 컴포넌트를 만든다
- **명확한 네이밍**: 페이지 이름을 잘 정하면 AI가 역할을 더 잘 이해한다

#### 디자인 시스템 통합
- **변수 매핑**: Figma 변수를 플러터 코드에 명확하게 연결한다
- **컴포넌트 재사용 규칙**: 일관된 컴포넌트 사용 가이드라인을 설정한다

## 세션 5: 기능을 넘어 뛰어난 사용자 경험을 가진 앱 만들기

### 뛰어난 UX를 만드는 핵심 원칙

좋은 앱은 단순히 기능만 제공하는 것이 아니라, 사용자에게 특별한 경험을 제공한다. 뛰어난 사용자 경험을 위한 세 가지 핵심 원칙:

#### 1. Positive and Inclusive (긍정적이고 포용적인)
- **긍정적인 피드백**: 사용자의 행동에 대해 긍정적으로 반응한다
- **포용적인 디자인**: 모든 사용자를 배려하는 접근성과 다양성을 고려한다
- **실패를 격려로**: 오류나 실패 상황에서도 사용자를 격려하고 다음 단계를 제시한다

#### 2. Creativity (창의성)
- **독창적인 인터랙션**: 기대하지 못한 즐거운 경험을 제공한다
- **개성 있는 디자인**: 브랜드의 정체성을 시각적/경험적으로 표현한다
- **재미 요소**: 기능적 필요성을 넘어 즐거움을 제공한다

#### 3. Sense (감각적인 경험)
- **자연스러운 애니메이션**: 물리 법칙을 따르는 부드러운 움직임
- **적절한 햅틱 피드백**: 촉각적 반응으로 몰입도를 높인다
- **일관된 디자인 시스템**: 예측 가능하면서도 만족스러운 경험

### 성공 사례 분석

#### Duolingo
- **긍정적 강화**: 학습 실패에도 격려 메시지와 귀여운 캐릭터로 동기 부여
- **게임화**: 연속 학습일, 리그 시스템으로 재미 요소 추가
- **감각적 피드백**: 정답 시 축하 애니메이션과 사운드 효과

#### Strava
- **커뮤니티 중심**: 친구들과 성과를 공유하고 경쟁하는 즐거움
- **성취감 제공**: 개인 기록 갱신, 배지, 순위 등으로 동기 부여
- **데이터 시각화**: 운동 데이터를 아름답고 의미 있게 표현

#### Capwords
- **직관적인 UI**: 복잡한 기능을 간단하게 제시
- **즉각적인 피드백**: 사용자 행동에 빠르게 반응
- **시각적 즐거움**: 타이포그래피와 색상으로 학습 경험 향상

### Flutter에서 UX 개선하기

#### 1. 애니메이션과 트랜지션
```dart
// 부드러운 페이지 전환
Hero(
  tag: 'item-image',
  child: Image.asset('item.png'),
)

// 자연스러운 상태 변화
AnimatedContainer(
  duration: Duration(milliseconds: 300),
  curve: Curves.easeInOut,
)
```

#### 2. 마이크로 인터랙션
- **로딩 상태**: 지루한 대기 시간을 흥미롭게 만드는 애니메이션
- **버튼 반응**: 탭/호버 시 시각적 피드백 제공
- **상태 변화**: 부드러운 트랜지션으로 맥락 유지

#### 3. 접근성 고려
```dart
// 스크린 리더 지원
Semantics(
  label: '홈 버튼',
  child: IconButton(...)
)

// 적절한 터치 영역 확보
SizedBox(
  width: 48,
  height: 48,
  child: InkWell(...)
)
```

#### 4. 성능 최적화
- **빠른 초기 로딩**: 사용자가 기다리지 않도록
- **부드러운 스크롤**: 60fps 이상 유지
- **효율적인 리소스 관리**: 메모리와 배터리 사용 최적화

### 핵심 요약

뛰어난 사용자 경험은 다음 요소들의 조화로 만들어진다:

1. **감정적 연결**: 사용자가 앱과 감정적으로 연결되도록 한다
2. **세심한 디테일**: 작은 인터랙션 하나하나에 신경 쓴다
3. **사용자 중심**: 기능이 아닌 사용자의 목표와 경험에 집중한다
4. **일관성과 예측 가능성**: 사용자가 편안하게 느끼도록 한다
5. **지속적인 개선**: 피드백을 듣고 계속 발전시킨다

Flutter는 이러한 뛰어난 UX를 구현하기 위한 강력한 도구들을 제공한다. 중요한 것은 기술이 아니라 사용자를 진정으로 이해하고 배려하는 마음이다.

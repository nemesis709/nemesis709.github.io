---
layout: post
title: "클린 아키텍처 5장: 객체지향 프로그래밍"
author: "Jin"
tags: Clean-Architecture
---

## 객체지향 프로그래밍

객체지향 프로그래밍은 무엇일까, 혹은 무엇으로 정의될 수 있는가에 대해 가장 흔하게 **캡슐화**, **상속**, **다형성**의 세 가지 요소로 설명한다.

그런데 과연 이 세 가지 속성이 객체지향에서만 가능한 것인지 살펴볼 필요가 있다.

## 캡슐화

**캡슐화**는 **데이터**와 해당 데이터를 처리하는 **메서드**를 하나의 객체 안에 묶는 것을 의미한다. 캡슐화를 통해 데이터는 외부에서 직접 접근할 수 없으며, 대신 객체의 메서드를 통해서만 접근할 수 있다. 이 방식은 **데이터 은닉**을 가능하게 한다.

객체지향 프로그래밍에서는 `private`과 `public` 키워드를 통해 쉽게 캡슐화를 할 수 있다. 하지만 **캡슐화는 객체지향만의 특징은 아니다**.

예를 들어, C 프로그래밍에서 **데이터 구조**와 **함수**를 헤더 파일에 선언하고, 구현 파일에서 이들을 구현하는 방식도 캡슐화의 예시다. 오히려 객체지향 언어에서 헤더와 구현체를 분리하는 방식을 포기함으로써 **캡슐화는 훼손되었다**.

## 상속

**상속**은 **부모 클래스**의 속성과 메서드를 **자식 클래스**가 물려받는 것을 의미한다. 이것은 객체지향의 분명한 특징이다.

하지만 C에서도 특정 클래스를 구현하고, 그에 대한 상위 클래스를 구현하며 **멤버 변수를 그대로 유지**하는 방식을 통해 상속과 비슷한 방식으로 개발할 수 있다.

따라서 **상속이 완전히 새로운 개념은 아니며**, 객체지향만의 특징으로 정의하기는 어렵다.

## 다형성

**다형성**은 **같은 이름의 메서드**가 **다른 기능**을 할 수 있도록 하는 것을 의미한다. 이는 **오버로딩(Overloading)**과 **오버라이딩(Overriding)**의 두 가지 형태로 나타난다.

C에서는 **함수 포인터**를 사용하여 특정 함수의 주소를 가리키고, 이를 통해 **동적으로** 다른 함수를 호출할 수 있다. 이러한 함수 포인터를 응용한 것이 **다형성**이다.

다형성이 중요한 이유는 **구체적인 객체가 무엇인지 몰라도 객체를 사용할 수 있기 때문**이다. **의존성 역전 원칙**은 고수준 모듈이 저수준 모듈에 직접 의존하지 않고 **추상화**에 의존하게 하는 원칙인데, 이 추상화된 부분을 다양한 방식으로 구현할 수 있게 해주는 것이 바로 **다형성**이다.

## 의존성 역전

**고수준 모듈**이란 **핵심 로직**, **비즈니스 로직**, 또는 **정책**으로 더 추상적이고 상위 개념을 다루는 모듈이다. 반면, **저수준 모듈**은 시스템의 **세부 구현**을 담당하는 모듈이다.

전통적인 소프트웨어 설계에서는 고수준 모듈이 저수준 모듈에 직접 의존하게 되는 경우가 많다. 이렇게 되면 저수준 모듈이 변경되면 고수준 모듈도 함께 수정해야 하므로, 시스템의 **유지보수성**이 떨어진다.

**의존성 역전 원칙**은 고수준 모듈이 저수준 모듈에 의존하는 것을 피하고, 고수준 모듈과 저수준 모듈 모두가 **추상화**에 의존하도록 만드는 설계 원칙이다.

이러한 시스템에서는 소프트웨어 아키텍트가 소스 코드 의존성을 원하는 방향으로 설정할 수 있다. 또한 각 컴포넌트는 **독립적**으로 변경이 가능하다. 이것이 **개발 독립성**이다.

즉, 객체지향이란 **다형성**을 이용하여 **전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력**이다.

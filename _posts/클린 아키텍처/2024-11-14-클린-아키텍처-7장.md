---
layout: post
title: "클린 아키텍처 7장: SOLID 원칙 - SRP(단일책임원칙)"
author: "Jin"
tags: CleanArchitecture
---
## SRP(단일책임원칙)

SRP(Single Responsibility Principle, 단일 책임 원칙)는 클래스나 모듈이 오직 하나의 책임을 가져야 한다는 것을 의미한다. 이때 '책임'이란 한 가지 기능이나 역할을 지칭하며, 모듈은 해당 기능에 관한 변경 요청에만 응답할 수 있어야 한다. **모듈**은 일반적으로 소스 파일처럼 여러 함수와 데이터 구조로 구성된 응집된 단위이다.

#### SRP가 지켜지지 않는 사례

**예시 1: 급여 계산 애플리케이션의 Employee 클래스**

급여 계산 애플리케이션에서, `Employee`라는 클래스가 세 가지 기능을 포함하고 있다고 가정하자.

- `calculatePay()`: 회계팀이 CFO에게 보고할 급여를 계산하기 위해 사용
- `reportHours()`: 인사팀이 COO에게 보고할 근무 시간을 관리하기 위해 사용
- `save()`: CTO와 DB 관리자가 데이터베이스에 정보를 저장하기 위해 사용

이 예시에서, `Employee` 클래스는 서로 다른 목적으로 사용하는 기능을 한데 모아둔 상태이다. 예를 들어, CFO 팀에서 근무 시간 관련 로직을 위해 `calculatePay()`와 `reportHours()`를 변경하다가, **COO 팀에 필요한 `reportHours()` 로직이 의도치 않게 수정되는** 상황이 발생할 수 있다. 이러한 문제는 `Employee` 클래스가 여러 팀의 요구를 동시에 충족하려 하기 때문에 생기는 문제이다. 이는 SRP 위반으로, 각 메서드를 별도의 책임 단위로 분리해야 한다.

**예시 2: 동시 수정에 의한 충돌**

또 다른 사례로, 동일한 `Employee` 클래스에서 `reportHours()` 메서드를 COO 팀이 수정하는 동시에, CTO 팀이 데이터베이스 스키마와 관련된 `save()` 메서드를 수정한다고 가정하자. 이러한 동시 수정은 서로의 의도와 다른 방식으로 코드를 수정할 수 있으며, 변경사항이 충돌하는 상황이 발생할 가능성이 높다. 이는 서로 다른 요구가 동일한 클래스에 얽혀있기 때문에 발생하는 문제로, SRP 위반에 해당한다.

### SRP를 지키기 위한 방법

SRP를 준수하려면 **클래스를 여러 클래스로 분리하여 각각의 메서드가 서로 다른 클래스에서 독립적으로 동작**하도록 하는 것이 중요하다. 각 기능을 책임 단위로 구분하면, 각각의 클래스는 단일 변경 이유만을 가지게 되어 유지보수가 쉬워지고 의도하지 않은 수정으로 인한 충돌을 줄일 수 있다.

1. **메서드를 별도 클래스로 분리**
   - 가장 기본적인 방법은 `calculatePay()`, `reportHours()`, `save()` 각각을 담당하는 클래스로 분리하고, `Employee`는 이 클래스를 관리하는 상위 객체로 둔다. 이렇게 하면 각 기능은 서로 독립적으로 변경할 수 있고, 필요에 따라 개별적으로 테스트할 수 있다.

2. **파사드(Facade) 패턴 사용**
   - 각 기능을 분리한 후, `EmployeeFacade`라는 클래스를 만들어 다른 클래스들이 직접 `calculatePay()`, `reportHours()`, `save()` 클래스를 호출하는 것이 아니라, 이를 대신 호출해주는 역할을 수행하도록 한다. 파사드 패턴을 사용하면 클래스 구조가 복잡해질 때 이러한 기능을 관리하기 쉽게 만들어 준다.

3. **기존 클래스의 역할 축소**
   - 경우에 따라 기존 `Employee` 클래스를 유지하되, 핵심적인 메서드만 남겨두고 다른 기능을 별도의 클래스로 분리할 수도 있다. 이 경우 `Employee` 클래스는 중요한 역할만 담당하며 파사드 클래스로써 분리된 다른 클래스를 호출하는 방식으로 사용할 수 있다. 
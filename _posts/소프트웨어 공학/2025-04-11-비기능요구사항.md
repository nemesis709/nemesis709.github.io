---
layout: post
title: "개발자노트: 비기능 요구사항, 시니어 개발자가 되려면 반드시 알아야 할 것들"
author: "Jin"
tags: 소프트웨어공학
---

## 왜 아키텍처가 엉망이 될까

프로젝트 초기에는 **"일단 기능만 잘 동작하면 되지"** 라는 생각으로 시작하는 경우가 많다.

그런데 실제 서비스를 운영해보니 **진짜 문제는 기능이 아니었다**. 기능은 잘 동작하는데 **"너무 느려서 못 쓰겠다"**, **"서버가 자꾸 죽는다"**, **"보안 이슈가 터졌다"** 는 문제들이 연달아 터져 나왔다.

특히 **개발 초기에는 이런 문제를 예상하기 어렵다**. 사용자들이 서비스를 실제로 이용하기 시작하고, 더욱이 **서비스가 성공하기 시작할 때** 이런 문제들이 진짜 발목을 잡는다.

나의 경우, 초기에 잘못 설계된 DB 구조 때문에 **사용자가 100명에서 1000명으로 늘어나는 순간** 쿼리 속도도 함께 10배가 늘어나버렸다. 기능적으로는 완벽했지만 **성능 요구사항을 전혀 고려하지 않았던** 것이다. 결국 **전체 아키텍처를 뜯어고쳐야** 했고, 그 과정에서 엄청난 리소스가 소모되었다.

회사 고문님께서 **"아키텍처가 엉망이 되는 이유는 비기능 요구사항을 모르고 설계하기 때문"** 이라고 하셨는데, 그때 정말 뼈저리게 느꼈다. 그리고 **"비기능 요구사항을 제대로 파악하는 것이 시니어 개발자의 핵심 역량"** 이라는 말씀도 함께.

기능만 구현하는 것은 주니어도 할 수 있지만, **시스템 전체의 품질과 안정성을 책임지는 것**이 바로 시니어의 역할이기 때문이다.

## 기능 요구사항 vs 비기능 요구사항

**기능 요구사항(Functional Requirements)**이 **"무엇을 해야 하는가"** 를 정의한다면, **비기능 요구사항(Non-Functional Requirements)**은 **"어떻게 동작해야 하는가"** 를 정의한다.

예를 들어:
- 기능 요구사항: "사용자는 로그인할 수 있어야 한다"
- 비기능 요구사항: "로그인 응답 시간은 2초 이내여야 한다", "99.9% 가용성을 보장해야 한다"

## 기능 × 비기능 매트릭스

시니어 개발자는 **모든 기능에 대해 비기능 요구사항을 체계적으로 매핑**한다. 다음과 같은 매트릭스로 접근하면 빠뜨리는 것 없이 설계할 수 있다:

| 기능 | 성능 | 보안 | 가용성 | 확장성 | 유지보수성 |
|------|------|------|--------|--------|------------|
| **사용자 인증** | 2초 이내 응답 | 2FA, JWT | 99.9% | OAuth 확장 | 표준 라이브러리 |
| **파일 업로드** | 100MB 5분 이내 | 바이러스 스캔 | CDN 다중화 | 청크 업로드 | 진행률 표시 |
| **실시간 채팅** | 100ms 지연 | 메시지 암호화 | WebSocket 장애복구 | 샤딩 | 메시지 큐 |
| **결제 처리** | 5초 이내 완료 | PCI DSS 준수 | 99.99% | MSA 분리 | 트랜잭션 로그 |

이런 식으로 **기능별로 비기능 요구사항을 명시적으로 정의**해야 빠뜨리는 것이 없다.

## 아키텍처 설계 원칙

비기능 요구사항을 고려한 아키텍처 설계에는 몇 가지 핵심 원칙이 있다:

### 1. 품질 속성 우선순위 결정
프로젝트마다 중요한 품질 속성이 다르다:
- **금융 시스템**: 보안 > 신뢰성 > 성능
- **게임**: 성능 > 가용성 > 확장성  
- **SNS**: 확장성 > 성능 > 가용성

### 2. 트레이드오프 인식
모든 비기능 요구사항을 동시에 만족시킬 수는 없다:
- **성능 vs 보안**: 캐싱과 인증의 균형
- **일관성 vs 가용성**: CAP 정리 적용
- **복잡성 vs 확장성**: 마이크로서비스 도입 시기

### 3. 측정 가능한 지표 설정
**"빠르게"** 대신 **"2초 이내"**, **"안전하게"** 대신 **"AES-256 암호화"** 로 구체화

## 핵심 비기능 요구사항 6가지

### 1. Performance (성능)

**측정 지표**:
```markdown
응답시간:
- 웹 페이지 로딩: 2초 이내
- API 응답: P95 < 500ms, P99 < 1000ms
- 앱 콜드 스타트: 3초 이내
- 데이터베이스 쿼리: 100ms 이내

처리량:
- 동시 접속자: 10,000명
- API 요청: 초당 1,000 TPS
- 파일 업로드: 100MB/s
```

**실무 도구**:
```bash
# 성능 테스트
jmeter -n -t loadtest.jmx -l results.jtl
lighthouse https://your-app.com --chrome-flags="--headless"

# Flutter 성능 프로파일링  
flutter build apk --profile
flutter run --profile --trace-startup
```

### 2. Security (보안)

**Authentication vs Authorization 구분**:
- **Authentication (인증)**: "누구인가?" - 신원 확인
- **Authorization (인가)**: "무엇을 할 수 있는가?" - 권한 확인

```markdown
인증 (Authentication):
- JWT + Refresh Token
- 2FA (TOTP, SMS)
- 소셜 로그인 (OAuth 2.0)
- 비밀번호: 최소 8자, 특수문자 포함

인가 (Authorization):
- RBAC (Role-Based Access Control)
- ABAC (Attribute-Based Access Control)  
- API Rate Limiting: 1000 req/min per user
- 리소스별 권한 매트릭스

데이터 보호:
- 저장 시: AES-256 암호화
- 전송 시: TLS 1.3
- 개인정보 마스킹: ***-****-1234
```

### 3. Reliability & Availability (신뢰성 & 가용성)

```markdown
가용성 목표:
- 99.9% = 월 43분 다운타임 허용 (일반 서비스)
- 99.99% = 월 4.3분 다운타임 허용 (금융/의료)

복구 목표 (장애 대응 핵심 지표):
1. RTO (Recovery Time Objective): 4시간
   → "장애 발생 시 얼마나 빨리 서비스를 복구할 것인가?"
   → 오전 9시 장애 → 오후 1시까지 복구 완료

2. RPO (Recovery Point Objective): 1시간  
   → "최대 얼마만큼의 데이터 손실을 허용할 것인가?"
   → 오전 9시 장애 → 오전 8시 이후 데이터 손실 허용

3. MTTR (Mean Time To Recovery): 30분
   → "평소에 장애를 얼마나 빨리 복구하고 있는가?"
   → 지난 10번 장애의 평균 복구 시간

비즈니스별 복구 목표 차이:
- 은행: RTO 30분, RPO 0분 (데이터 손실 절대 불가)
- 전자상거래: RTO 1시간, RPO 15분 (매출 직접 타격)
- 사내 시스템: RTO 4시간, RPO 1시간 (업무 지연 허용)

MTTR 단축 전략:
- 자동 모니터링: 장애 5분 내 감지
- 자동 알림: Slack/SMS로 즉시 통보  
- 자동 복구: 간단한 장애는 자동 재시작
- 런북(Runbook): 장애 대응 매뉴얼 미리 준비

실제 장애 상황 예시:
09:00 - 데이터베이스 서버 다운 (장애 발생)
09:05 - 모니터링 시스템이 장애 감지
09:30 - 엔지니어가 복구 작업 완료
10:00 - 서비스 정상화 확인

결과 분석:
✅ RTO 목표(4시간) vs 실제(1시간) → 달성
✅ RPO 목표(1시간) vs 실제(30분 데이터 손실) → 달성  
❌ MTTR 목표(30분) vs 실제(1시간) → 목표 초과
```

### 4. Scalability (확장성)

**수직 확장 vs 수평 확장**:
- **Scale Up**: 서버 스펙 증가 (간단하지만 한계 존재)
- **Scale Out**: 서버 대수 증가 (복잡하지만 무한 확장)

**확장 전략**:
```markdown
데이터베이스:
- Read Replica: 읽기 성능 향상
- Sharding: 데이터 분산
- Partitioning: 테이블 분할

애플리케이션:
- 로드밸런서: 트래픽 분산  
- 캐싱: Redis, CDN
- 비동기 처리: 메시지 큐
```

**실제 확장 시나리오와 아키텍처 설계**

**시나리오 1: 기존 사용자 시스템 활용한 신규 서비스 확장**
```markdown
상황: 기존 100만 사용자 쇼핑몰에 라이브 커머스 기능 추가

기존 모놀리식 구조의 문제점:
- 사용자 인증 API 부하: 기존 10 TPS → 500 TPS 추가 (50배 증가)
- 데이터베이스 병목: 복잡한 조인 쿼리로 응답시간 급증
- 배포 리스크: 새 기능 배포 시 전체 서비스 중단 위험
- 팀 간 의존성: 라이브 팀과 쇼핑몰 팀의 배포 일정 충돌

MSA(Microservices Architecture) 적용:
1. 사용자 서비스 분리:
   - 독립적인 사용자 DB와 API 구성
   - JWT 토큰 기반 인증으로 서비스 간 연동
   
2. 라이브 커머스 서비스:
   - 별도 인프라와 데이터베이스
   - 실시간 스트리밍에 최적화된 아키텍처

3. API Gateway 도입:
   - 라우팅과 인증 중앙화
   - Rate Limiting으로 부하 제어
```

**시나리오 2: 데이터 중심 확장성 설계**
```markdown
상황: 채팅 서비스가 10만 → 1000만 사용자로 확장

데이터 증가 패턴 분석:
- 사용자: 100배 증가
- 채팅방: 1,000배 증가 (그룹 채팅, 커뮤니티 기능)
- 메시지: 10,000배 증가 (활성도와 기능 증가)

샤딩(Sharding) 전략:
1. 채팅방 기반 샤딩:
   - 방 ID % N으로 서버 분산
   - 같은 방의 메시지는 동일 서버에 저장

2. 사용자 인덱스 서버:
   - 사용자가 속한 방들의 샤드 정보 관리
   - 빠른 라우팅을 위한 캐싱

3. 메시지 아카이빙:
   - 90일 이후 메시지는 콜드 스토리지로 이동
   - 검색 기능을 위한 Elasticsearch 별도 구축
```

**시나리오 3: 글로벌 확장과 지역별 최적화**
```markdown
상황: 국내 서비스를 동남아시아로 확장

지역별 특성 고려:
- 한국: 빠른 네트워크, 고사양 디바이스, 실시간 상호작용 선호
- 동남아: 느린 모바일 네트워크, 저사양 디바이스, 오프라인 우선

아키텍처 분리 전략:
1. 지역별 CDN:
   - 이미지, 비디오 등 정적 콘텐츠 최적화
   - 네트워크 레이턴시 50% 이상 개선

2. Edge Computing:
   - 지역별 API 서버 배치 (싱가포르, 자카르타)
   - 핵심 기능만 로컬 처리, 나머지는 중앙 서버

3. 데이터 동기화:
   - 사용자 프로필: 실시간 동기화
   - 콘텐츠 메타데이터: 배치 처리
   - 분석 데이터: 일별 동기화
```

**확장성 설계 원칙**

**1. 단계별 확장 전략**
```markdown
0-1만 사용자: 모놀리식 + 단일 DB
→ 빠른 개발, 단순한 배포

1-10만 사용자: 캐싱 + Read Replica
→ 읽기 성능 최적화, DB 부하 분산

10-100만 사용자: MSA 도입 시작
→ 핵심 서비스별 분리, 독립적 스케일링

100만+ 사용자: 본격적 분산 시스템
→ 샤딩, 글로벌 배포, 멀티 리전
```

**2. 확장성과 비용의 트레이드오프**
```markdown
확장 방식별 비용 비교:

Scale Up (수직 확장):
- 초기 비용: 낮음
- 개발 복잡도: 낮음
- 확장 한계: 명확함
- 적용 시기: 초기 스타트업

Scale Out (수평 확장):
- 초기 비용: 높음
- 개발 복잡도: 높음
- 확장 한계: 거의 없음
- 적용 시기: 성장 단계

하이브리드 접근:
- 상태 없는 서비스: Scale Out
- 데이터베이스: Scale Up + Read Replica
- 캐시: Scale Out
```

### 5. Maintainability (유지보수성)

```markdown
코드 품질:
- Test Coverage: 80% 이상
- Cyclomatic Complexity: 10 이하
- Code Duplication: 5% 이하
- Technical Debt: SonarQube A등급

배포 자동화:
- CI/CD 파이프라인
- Blue-Green 배포
- Canary 배포 (10% → 50% → 100%)
- 자동 롤백
```

### 6. Cost (비용) - 페르미 추정

비기능 요구사항을 만족시키는 **비용을 미리 추정**하는 것도 시니어의 역할이다.

**페르미 추정이란?**
복잡한 문제를 **간단한 가정들로 나누어** 대략적인 답을 구하는 방법이다. 정확한 데이터가 없어도 **합리적인 추정**을 통해 의사결정을 돕는다.

**왜 시니어 개발자에게 중요한가?**
- **예산 승인**: "서버 비용이 얼마나 들까요?" 질문에 답할 수 있어야 함
- **기술적 의사결정**: A안 vs B안 중 어느 것이 비용 효율적인가?
- **스케일링 계획**: 사용자가 10배 늘어나면 비용도 10배 늘어날까?

**페르미 추정 4단계 접근법**:

**1단계: 문제 분해**
```markdown
"우리 서비스 운영 비용이 얼마나 될까?"
↓
- 사용자 규모는?
- 사용 패턴은?
- 필요한 리소스는?
- 각 리소스 단가는?
```

**2단계: 가정 설정**
```markdown
현실적인 범위 내에서 가정:
- "일반적으로 사용자는..."
- "비슷한 서비스들은..."
- "업계 평균적으로..."
```

**3단계: 계산**
```markdown
단순한 곱셈/나눗셈으로:
- 사용자 수 × 사용량 = 총 부하
- 총 부하 ÷ 서버 용량 = 필요 서버 수
- 서버 수 × 서버 단가 = 총 비용
```

**4단계: 검증 및 조정**
```markdown
"이 결과가 말이 되나?"
- 비슷한 규모 서비스와 비교
- 10배, 0.1배 범위에서 조정
- 여러 시나리오 고려
```

**실무 페르미 추정 예시들**:

**예시 1: 스타트업 MVP 비용**
```markdown
목표: 월 1만명 사용자 서비스

1. 사용 패턴 가정:
   - DAU: 3,000명 (30%)
   - 일평균 세션: 사용자당 2회
   - 세션당 API 요청: 20회
   - 일일 총 요청: 120,000회

2. 인프라 요구사항:
   - API 서버: t3.micro 2대 = $20/월
   - DB: t3.micro RDS = $15/월
   - 스토리지: 100GB = $10/월
   
3. 결과: 약 $45/월 (5만원/월)
```

**예시 2: 대규모 확장 시나리오**
```markdown
현재 10만 사용자 → 100만 사용자로 확장

1. 선형 확장 가정:
   - DB 읽기: 10배 증가 → Read Replica 필요
   - API 서버: 10배 증가 → Auto Scaling
   - 스토리지: 10배 증가 → 객체 스토리지

2. 비선형 요소:
   - 캐싱 효율: 10배가 아닌 5배 정도 증가
   - CDN 효과: 트래픽 50% 절약
   - 모니터링: 복잡도 증가로 3배 비용

3. 최종 추정: 현재 비용의 7-8배
```

**예시 3: 성능 개선 비용 vs 효과**
```markdown
API 응답시간을 1000ms → 300ms로 개선

A안 - 서버 스케일 업:
- 비용: 기존 대비 200% (2배)
- 효과: 응답시간 50% 단축

B안 - 캐싱 도입:
- 비용: 기존 대비 120% (Redis + 개발비)
- 효과: 응답시간 70% 단축

→ B안이 비용 효율적
```

이런 식으로 **"대충 이 정도"** 가 아닌 **"근거 있는 추정"** 을 할 수 있어야 시니어 개발자다.

## 마무리

비기능 요구사항은 **보이지 않는 품질**이다. 사용자는 직접적으로 인식하지 못하지만, 이것이 없으면 서비스가 제대로 동작하지 않는다.

주니어 시절의 나는 **"일단 돌아가게 만들자"** 에 집중했다면, 이제는 **"어떻게 하면 안정적이고 확장 가능하게 만들 수 있을까"** 를 먼저 고민한다.

이 경험을 통해 깨달은 것은, **아키텍처가 엉망이 되는 가장 큰 이유는 비기능 요구사항을 모르고 설계하기 때문**이라는 점이다. 그리고 **비기능 요구사항을 체계적으로 다루는 능력**이 바로 시니어 개발자와 주니어 개발자를 나누는 결정적 차이점이라고 확신한다.

다음 프로젝트에서는 기능 구현에 앞서:
1. **"이 시스템이 어느 정도 규모까지 견딜 수 있을까?"**  
2. **"각 기능별로 어떤 품질 속성이 중요할까?"**
3. **"이를 만족시키려면 비용이 얼마나 들까?"**

이 세 가지 질문부터 시작해보자. 그 순간부터 시니어 개발자의 사고방식으로 접근하고 있는 것이다. 
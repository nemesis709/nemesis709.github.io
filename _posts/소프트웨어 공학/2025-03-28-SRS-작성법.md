---
layout: post
title: "개발자노트: SRS(소프트웨어 요구사항 명세서) 제대로 작성하는 방법"
author: "Jin"
tags: 소프트웨어공학
---

## SRS를 왜 작성해야 할까

프로젝트를 진행하다 보면 **"이 기능이 원래 이랬던가?"** 라는 질문이 자주 나온다. 개발 중간에 요구사항이 바뀌거나, 팀원마다 기능에 대한 이해가 다르거나, 완성된 기능이 기획 의도와 다른 경우가 생기기 때문이다.

대부분 이런 상황은 **"일단 시작하고 가면서 정하자"** 라는 접근법에서 시작된다.

실제로 나도 프로젝트를 진행하면서 개발 막바지에 **전체 시스템을 재설계**해야 하는 상황을 겪었다. 처음에는 간단한 기능 추가인 줄 알았는데, 기존 구조와 맞지 않아서 **전면 수정**이 필요했던 것이다. 결국 **일정은 두 배로 늘어나고**, 팀원들의 스트레스도 극에 달했다.

이런 경험은 나뿐만 아니라 **많은 개발자들이 공통으로 겪는 문제**라고 생각한다.

이런 상황을 방지하려면 **SRS(Software Requirements Specification)**를 제대로 작성해야 한다. 요구사항과 스펙을 명확히 정의해두면, 개발 과정에서 발생하는 **불필요한 재작업을 크게 줄일 수 있다**.

## SRS에 대한 잘못된 통념들

### "스펙 쓰느라 일정 못 맞추는 거 아냐?"

이건 **원래 시간이 부족한 프로젝트**라는 뜻이다. SRS 작성 시간을 아끼려다가 나중에 **재개발로 더 많은 시간을 소비**하게 된다.

### "기능 잘 적고 말로 공유하면 되는 거 아냐?"

구두 전달은 **오해의 소지**가 크다. 사람마다 이해하는 방식이 다르고, 시간이 지나면 **기억도 왜곡**된다.

### "일단 시작하고 가면서 정하자"

이 방식의 결과는 뻔하다. **재개발 때문에 더 늦어진다**. 특히 아키텍처 레벨의 변경이 필요할 때는 치명적이다.

## SRS 작성의 3가지 핵심 원칙

### 1. 정확한 의사 전달하기

모든 팀원이 **같은 내용을 같은 방식으로** 이해할 수 있도록 작성한다.

### 2. 설계의 기초 마련하기

개발자가 구현할 때 **참고할 수 있는 구체적인 가이드**를 제공한다.

### 3. 중복 피하기

시스템이 바뀌면 문서도 바뀌어야 하므로, **중복을 없애야 수정하기 편하다**.

## SRS 문서 구조와 작성 요령 (IEEE 830 표준 기반)

### 기본 작성 원칙

- **IEEE 830 표준 구조를 따른다** (국제 표준 준수)
- 필요 없는 내용은 **"생략" 또는 "N/A"**로 표시
- **기술적 상세도를 높여라** - 구현 가능한 수준까지
- **플랫폼별 요구사항을 분리**하여 작성 (웹/앱/백엔드)

# **1** Introduction (개요)

## 1.1 Purpose (목표)
**문서의 목적, 대상 독자, 기술 범위**를 명확히 정의한다.

```markdown
본 문서는 TaskFlow 모바일 앱의 소프트웨어 요구사항 명세서입니다.
개발팀을 대상으로 작성되었으며, 크로스플랫폼 태스크 관리 시스템의 
상세 요구사항을 정의합니다.

대상 독자:
- 웹 프론트엔드 개발팀: 2-7장 전체 검토 필요
- 앱 개발팀: 2-7장 전체 검토 필요  
- QA팀: 5-7장 중점 검토
- 프로덕트팀: 1-2장, 7장 중점 검토
```

## 1.2 Product Scope (범위)
**비즈니스 목표와 기술적 범위**를 명확히 구분하고, **제외사항을 구체적으로** 명시한다.

```markdown
## 개발 범위

### 포함 사항
- Flutter 기반 크로스플랫폼 앱 (Android/iOS)
- React/Next.js 기반 웹 관리자 도구
- NestJS 백엔드 API 서버
- 실시간 알림 시스템 (WebSocket + FCM)

### 제외 사항  
- 웹 버전 사용자 앱 (1단계에서 제외)
- 외부 시스템 연동 (Slack, Teams 등)
- 결제/구독 기능
- 음성/화상 통화 기능
```

## 1.3 Document Conventions (문서 규칙)
**기술 용어, 우선순위, 표기법**을 정의한다.

## 1.4 Terms and Abbreviations (정의 및 약어)
**도메인 특화 용어**들을 정의한다.

## 1.5 Related Documents (관련 문서)
**API 명세, 아키텍처 문서** 등을 참조한다.

# **2** Overall Description (전체 설명)

## 2.1 Product Perspective (제품 조망)
**시스템 아키텍처와 외부 의존성**을 다이어그램으로 표현한다.

```markdown
┌─────────────────┐    HTTP/REST    ┌─────────────────┐
│   Flutter App   │ ←→ │   API Server    │
└─────────────────┘                 └─────────────────┘
        ↓                                   ↓
┌─────────────────┐                 ┌─────────────────┐
│   FCM Push      │                 │   PostgreSQL    │
└─────────────────┘                 └─────────────────┘
```

## 2.2 Overall System Configuration (전체 시스템 구성)
**시스템 구성 요소와 상호작용**을 설명한다.

## 2.3 Overall Operation (전체 동작방식)
**주요 동작 시나리오와 워크플로우**를 기술한다.

## 2.4 Product Functions (제품 주요 기능)
프로젝트에 포함되는 **주요 기능**에 대해 언급한다.

## 2.5 User Classes and Characteristics (사용자 계층과 특징)
**각 사용자 유형별 권한과 특성**을 구체적으로 정의한다.

## 2.6 Assumptions and Dependencies (가정과 종속 관계)
**개발 전제조건과 외부 의존성**을 명시한다.

## 2.7 Apportioning of Requirements (단계별 요구사항)
**MVP, Phase 2, Phase 3**로 명확히 구분한다.

# **3** Environment (환경)

## 3.1 Operating Environment (운영 환경)
**지원 OS, 브라우저, 디바이스 스펙**을 명시한다.

## 3.2 Development Environment (개발 환경)
**구체적인 기술 스택과 버전**을 명시한다.

```markdown
웹 개발 환경:
- Node.js 18.x
- Next.js 13.x (App Router)
- React 18.x
- TypeScript 5.x
- TailwindCSS 3.x

앱 개발 환경:
- Flutter SDK 3.16+
- Dart SDK 3.2+
- Android Studio / Xcode
```

## 3.3 Distribution Environment (배포 환경)
**운영 서버, CDN, 앱스토어 배포** 환경을 정의한다.

## 3.4 Test Environment (테스트 환경)
**테스트 도구, 디바이스, 자동화** 환경을 명시한다.

# **4** External Interface Requirements (외부 인터페이스 요구사항)

## 4.1 User Interface (사용자 인터페이스)
**구체적인 UI 가이드라인과 디자인 시스템**을 참조한다.

## 4.2 Hardware Interface (하드웨어 인터페이스)  
**카메라, GPS, 생체인식** 등 하드웨어 사용 요구사항을 명시한다.

## 4.3 Software Interface (소프트웨어 인터페이스)
**외부 API, SDK, 라이브러리** 연동 사양을 정의한다.

## 4.4 Communication Interface (통신 인터페이스)
**네트워크 프로토콜, 데이터 형식, 보안** 요구사항을 명시한다.

# **5** Performance requirements (성능 요구사항)

## 5.1 Throughput (작업처리량)
**동시 사용자, 트랜잭션 처리량**을 명시한다.

## 5.2 Response Time (대응시간)
**측정 가능한 구체적 수치**로 정의한다.

```markdown
- 앱 콜드 스타트: 3초 이내
- API 응답 시간: P95 < 500ms, P99 < 1000ms
- 동시 접속자: 10,000명 지원
- 데이터 동기화: 실시간 (WebSocket 1초 이내)
- 메모리 사용량: 최대 200MB (앱)
- 배터리 소모: 일 8시간 사용 시 20% 이내
```

## 5.3 Capacity (용량)
**저장소, 네트워크 대역폭** 요구사항을 정의한다.

## 5.4 Performance Dependency (성능 종속 관계)
**하드웨어, 네트워크 의존성**을 명시한다.

# **6** Non-Functional Requirements (기능 이외의 요구사항)

## 6.1 Safety requirements (안전성 요구사항)
**데이터 손실 방지, 복구 절차**를 구체적으로 정의한다.

```markdown
데이터 백업 정책:
1. 실시간 데이터베이스 리플리케이션
2. 일일 풀 백업 (30일 보관)
3. 증분 백업 (6시간 간격)
4. 재해 복구 RTO: 4시간, RPO: 1시간
```

## 6.2 Security Requirements (보안 요구사항)
**인증, 인가, 데이터 암호화** 요구사항을 명시한다.

```markdown
인증/인가 체계:
- JWT 기반 토큰 인증
- Role-based Access Control (RBAC)
- API Rate Limiting: 사용자당 1000 req/min
- 데이터 암호화: AES-256 (저장), TLS 1.3 (전송)
- 개인정보 마스킹: 전화번호, 이메일 부분 가림
```

## 6.3 Software System Attributes (소프트웨어 시스템 특성)
**가용성, 신뢰성, 유지보수성**을 구체적 지표로 정의한다.

```markdown
- 가용성: 99.9% (월 43분 다운타임 허용)
- 장애 감지: 30초 이내 자동 알림
- 자동 복구: 경미한 장애 3분 이내 자동 복구
- 코드 커버리지: 단위 테스트 80% 이상
- 기술 부채: SonarQube A등급 유지
```

## 6.4 Logical Database Requirements (데이터베이스 요구사항)
**데이터 모델, 트랜잭션, 백업 정책**을 명시한다.

## 6.5 Business Rules (비즈니스 규칙)
**도메인 특화 규칙과 정책**을 정의한다.

## 6.6 Design and Implementation Constraints (설계와 구현 제한사항)
**기술적 제약사항과 표준 준수** 요구사항을 명시한다.

# **7** Functional Requirements (기능요구사항)

**가장 중요한 섹션**으로, 구현 가능한 수준까지 상세히 작성한다.

## 7.1 핵심 기능별 상세 명세
**각 기능을 독립적인 하위 섹션으로** 구성한다.

```markdown
## 7.1 사용자 인증 시스템

### 7.1.1 로그인 프로세스
- 이메일/패스워드 검증
- 2FA 지원 (TOTP)
- 소셜 로그인 (Google, Apple)
- 실패 시 계정 잠금 (5회 실패 시 1시간)

### 7.1.2 세션 관리
- Access Token: 15분 만료
- Refresh Token: 30일 만료
- 동시 로그인: 최대 3개 디바이스
```

## 7.2 데이터 모델 및 비즈니스 로직
**엔티티 관계, 상태 전이, 검증 규칙**을 포함한다.

## 7.3 API 인터페이스 명세
**엔드포인트별 요청/응답 스키마**를 정의한다.

## 7.4 플랫폼별 특화 기능
**Flutter 위젯, React 컴포넌트** 등 플랫폼 고유 기능을 명시한다.

## SRS 작성 실전 팁

### 1. 3단계 작성법

1. **목표 한 줄** - 핵심 목표를 명확히 정의
2. **주요 기능 다섯 가지** - 핵심 기능만 추려서 나열  
3. **살 붙이기** - 세부 사항과 예외 처리 추가

### 2. 리뷰 과정

- **SRS 리뷰에 하루 전체를 할애**해도 아깝지 않다
- 리뷰를 여러 번 하면 **변경 사항 추적이 어려우므로** 버전 관리를 철저히 한다
- **모든 이해관계자가 참여**하는 리뷰 미팅을 진행한다

### 3. 품질 특성 고려

#### 내부 특성
- 안전성, 보안성, 가용성

#### 외부 특성  
- 유지보수성, 이식성, 연동성

## 마무리

처음 SRS 작성을 시작할 때는 **"이걸 언제 다 써?"** 라는 생각이 들 수 있다. 나도 그랬다.

하지만 실제로 경험해보니, 재개발 가능성이 현저히 줄어들기 때문에 프로젝트의 일정과 범위가 관리 가능해지는 것을 경험했다. 프로젝트가 바뀌는 것은 당연하지만, **체계적이고 투명한 방식으로 변경**될 때 모든 팀원이 납득할 수 있다.

실제로 SRS를 제대로 작성한 프로젝트에서는:
- **"이 기능이 뭐였지?"** 라는 질문이 현저히 줄어들었고
- 개발 중간에 **전체 시스템 재설계**를 해야 하는 상황도 피할 수 있었다
- 신규 팀원이 합류해도 **빠른 온보딩**이 가능했다

물론 처음에는 시간 투자가 필요하다. 하지만 전체 프로젝트 관점에서 보면 **절대 손해 보지 않는 투자**라고 확신한다.

**한 가지 중요한 점**: 위에서 소개한 항목들은 **IEEE 국제 표준**이므로 임의로 순서를 바꾸거나 이름을 변경하면 안 된다. 이 구조 자체가 수십 년간의 소프트웨어 개발 경험이 집약된 결과물이기 때문이다.

특히 팀 단위로 개발할 때는 SRS가 **모든 소통의 기준점**이 된다. **"문서에 없으면 구현하지 않는다"** 는 원칙으로 접근하면, 놀랍게도 프로젝트가 훨씬 체계적으로 진행된다.

SRS 작성, 처음에는 번거롭지만 **한 번 익숙해지면 없어서는 안 될 개발 도구**가 될 것이다. 다음 프로젝트에서는 꼭 시도해보기를 추천한다.

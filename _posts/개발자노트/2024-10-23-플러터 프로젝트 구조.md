---
layout: post
title: "개발자노트: 프로젝트 구조 정하기"
author: "Jin"
tags: 개발자노트
---
## 프로젝트 구조 정하기

혼자 개발할 때는 구조에 큰 신경을 쓰지 않아도 되지만, 프로젝트가 커지면 유지보수성과 테스트 용이성을 높이기 위해 구조화가 중요해진다. 올바른 프로젝트 구조는 코드의 가독성과 재사용성을 높이고, 팀 협업에 필요한 일관성을 제공한다. 또한 규모가 큰 애플리케이션에서 다양한 기능을 확장하거나 오류를 빠르게 해결할 수 있게 한다.

## MVVM 패턴

MVVM(Model-View-ViewModel) 패턴은 뷰(View)와 모델(Model)을 분리하여, 각자의 책임을 명확히 하면서도 의존성을 줄일 수 있다. MVVM을 사용하면 `View`는 `ViewModel`에 있는 데이터에 바인딩되고, `ViewModel`이 비즈니스 로직을 처리해 `Model`과의 데이터 상호작용을 관리한다. 

### MVVM의 장점

- **의존성 분리**: `View`는 `Model`과 직접 상호작용하지 않고, `ViewModel`을 통해 필요한 데이터와 상태를 가져온다. 이렇게 하면 UI와 비즈니스 로직을 독립적으로 개발하고 유지보수할 수 있다.
- **단방향 데이터 흐름**: 데이터는 `Model`에서 `ViewModel`로, 그리고 `ViewModel`에서 `View`로 흐르며, 이로 인해 상태 추적이 쉬워진다.
- **테스트 가능성**: `ViewModel`은 UI와 분리되어 있어 테스트 작성이 용이하다. 비즈니스 로직을 `ViewModel`에 포함하면 `View`가 없어도 독립적으로 테스트할 수 있다.

## Repository 패턴

Repository 패턴은 데이터 소스(API, 로컬 DB 등)에 접근하는 방식을 추상화하여 비즈니스 로직과 데이터 소스 간의 의존성을 줄이는 역할을 한다. 

### Repository 패턴이 필요한 이유

- **유지보수성**: 만약 비즈니스 로직에서 API를 직접 호출하면, API 주소나 데이터 구조가 변경될 때마다 모든 비즈니스 로직에 영향을 미친다. 그러나 Repository를 통해 API 호출을 분리해 두면, 데이터 소스 관련 수정은 Repository 내에서만 이루어지므로 코드 수정이 간단해진다.
- **데이터 소스 교체 용이**: 예를 들어, 초기에는 API를 통해 데이터를 가져오다가 로컬 DB로 대체해야 할 경우, Repository 내부에서 데이터 소스를 변경하면 된다. 비즈니스 로직을 변경하지 않고도 쉽게 데이터 소스를 전환할 수 있다.
- **테스트 용이성**: Repository는 인터페이스를 통해 구현되므로, 테스트에서 Mock Repository를 주입하여 데이터 소스를 쉽게 대체할 수 있다. 이를 통해 API와 독립적으로 비즈니스 로직을 테스트할 수 있다.

## Presentation 레이어

프레젠테이션 레이어는 사용자 인터페이스(UI)와 사용자 상호작용을 처리하는 역할을 담당한다. MVVM 구조에서 View와 ViewModel을 포함한다.

### Widgets & States (View)

사용자가 볼 수 있는 화면(UI 요소)을 담당하며, 데이터를 시각적으로 표시하고 사용자 입력을 처리한다.

- **반응형 UI** : View는 데이터 바인딩(Data Binding) 또는 상태(State)에 따라 ViewModel로부터 데이터를 실시간으로 가져와 UI를 업데이트한다.
- **로직 최소화** : 비즈니스 로직을 포함하지 않으며, ViewModel에서 전달받은 데이터를 표시한다.

### Controller (ViewModel)

View와 Model 간의 중개자 역할을 수행하며, View와 데이터(비즈니스 로직) 사이의 의존성을 분리한다.

- **상태 관리** : 앱 상태를 관리하며, 상태 변경 사항을 View로 전달한다.
- **UI 이벤트 처리** : 사용자가 발생시키는 이벤트(버튼 클릭, 입력 등)를 받아 처리하고, 필요한 경우 Model과 상호작용한다.
- **의존성 주입(DI)** : ViewModel은 Model 또는 Repository에 의존하지만, 직접적으로 인스턴스를 생성하지는 않는다.

## API 레이어와 DTO(Data Transfer Object) 레이어

프로젝트 구조에서 API와 DTO를 별도의 레이어로 구성하면, 데이터의 유지보수성과 확장성을 높일 수 있다.

### API 레이어

API 레이어는 서버의 API 명세대로 작성하여 네트워크 통신을 전담하는 역할을 담당한다. 이 레이어에서는 서버와의 요청과 응답을 처리하고, 이를 통해 받은 데이터는 그대로 DTO로 전달된다. 

- **책임 분리**: API 호출 및 응답 처리를 전담하여 네트워크 관련 로직이 다른 코드와 섞이지 않도록 한다.
- **유지보수성**: 서버 API가 변경되면 이 레이어에서만 수정하면 되므로, 데이터 처리 로직과 독립적으로 관리할 수 있다.

### DTO(Data Transfer Object) 레이어

DTO 레이어는 API에서 받은 데이터의 구조를 앱 내부에서 사용하기 쉽게 변환한다. 대규모 프로젝트에서는 서버의 데이터 구조가 앱의 요구사항과 일치하지 않거나, 서로 다른 데이터 소스(API, 로컬 DB 등)에서 데이터를 받는 경우가 많기 때문에 DTO 레이어가 유용하다.

- **데이터 변환과 가공**: 예를 들어, 서버에서 받는 데이터 구조가 앱에서 필요한 구조와 다를 때 DTO 레이어에서 이를 가공하여 `Model`로 변환한다.
- **호환성 유지**: 앱에서 필요한 데이터 필드가 서버에서 제공되지 않거나 반대로 불필요한 필드가 있을 경우, DTO를 사용해 필요한 필드만 포함한 새로운 구조로 정의할 수 있다.
- **재사용성**: 다양한 데이터 소스를 사용하게 되는 경우, DTO는 데이터 소스 간의 일관성을 유지하고, 중복 코드 작성을 줄일 수 있다. 

## Domain 레이어

도메인 레이어는 MVVM 패턴에서 **모델(Model)**에 해당하며, 데이터의 구조를 정의하고, 모델에 관한 다양한 메서드를 포함한다.

도메인 레이어를 두는 이유는 데이터와 관련된 모든 처리 로직을 도메인 레이어에 집중시켜 **UI와 데이터 간의 결합을 줄이고** 재사용성을 높이기 위함이다.

예를 들어:
- **DTO 변환 메서드**: 네트워크나 데이터베이스로부터 받아온 DTO 객체를 도메인 레이어의 모델 객체로 변환하는 메서드를 작성할 수 있다.
- **유효성 검사 메서드**: 모델 데이터가 가진 값의 유효성을 검사하는 메서드를 도메인 레이어에서 구현하여 비즈니스 로직의 신뢰성을 높일 수 있다.

## Service 레이어

서비스 레이어는 앱 전역적으로 필요한 데이터를 관리하거나 특정 레이어에 두기 애매한 데이터를 저장하는 곳이다. **유저 정보, 앱의 빌드 환경** 등 다양한 상태나 기능들을 담을 수 있으며, 특히 애플리케이션 전반에서 공유하거나 참조해야 하는 상태가 있을 때 유용하다.

이 레이어는 주로 **GetIt**과 같은 의존성 주입 라이브러리와 함께 사용하여 앱 전역에서 쉽게 접근할 수 있도록 한다. GetIt을 활용하면 서비스 인스턴스를 전역에서 안전하게 주입하고 재사용할 수 있으며, 앱이 커질수록 객체 생성과 관리를 일관성 있게 유지할 수 있다.

## Feature-first vs Layer-first

이렇게 레이어를 분리하고 나면 프로젝트 구조를 결정해야 하는데, 크게 Feature-first(기능 기준)와  Layer-first(레이어 기준)로 나눌 수 있다.

### Feature-first

**Feature-first** 구조는 기능을 중심으로 코드를 분리하는 방식이다.
예를 들어, "사용자", "상품", "주문"과 같은 도메인 단위로 코드를 관리한다.

**장점**

1. 새로운 기능 추가 및 수정 용이성
- 기능별로 코드가 독립적으로 구성되어 있어 특정 기능을 추가하거나 수정할 때 전체 프로젝트에 미치는 영향을 최소화할 수 있다.
- 기능 요구사항의 추가 또는 변경이 잦은 프로젝트에 적합하다.
2. 개발 효율성 향상
- 도메인별로 코드가 모여 있어 이해하기 쉽고, 협업 시 충돌을 줄일 수 있다.
- 팀이 기능 단위로 나뉘어 작업할 때 유리하다.
3. 확장성
- 새로운 기능이 추가될 때 기존 구조에 영향을 주지 않고 새로운 폴더나 모듈만 추가하면 된다.

**단점**

1. 공통 코드 관리의 복잡성
- 여러 기능에서 공유되는 로직(예: 유틸리티, 공통 서비스 등)을 관리하기 위해 common 폴더가 필요하다. 이때 프로젝트 규모가 커지면 common 폴더가 지나치게 비대해지고, 공통 코드의 변경이 전체 프로젝트에 영향을 미칠 위험이 있다.
2. 의존성 관리의 어려움
- 기능 간 의존성이 발생하면 코드 간의 연결이 복잡해질 수 있다.
- 의존성 순환 문제를 방지하기 위해 철저한 관리가 필요하다.

### Layer-first

**Layer-first** 구조는 애플리케이션의 아키텍처 레이어(예: 컨트롤러, 서비스, 리포지토리)를 중심으로 코드를 분리한다.

**장점**

1. 구조적 명확성
- 프로젝트 규모가 커지더라도 각 레이어의 역할이 명확하게 구분되어 폴더 구조가 깔끔하게 유지된다.
- 예를 들어, 모든 서비스 로직은 services 폴더에, 데이터베이스 접근 로직은 repositories 폴더에 위치한다.

2. 일관성
- 동일한 레이어에서 작업하는 코드는 동일한 패턴을 따르므로 개발자가 새로운 코드를 작성하거나 기존 코드를 이해하기 쉽다.
- 코드 리뷰와 품질 관리가 용이하다.
3. 중복 코드 최소화
- 공통 기능은 레이어별로 집중적으로 관리되므로 중복 코드를 줄일 수 있다.

**단점**

1. 기능 추가 및 수정의 번거로움
- 새로운 기능을 추가하려면 여러 레이어(컨트롤러, 서비스, 리포지토리 등)를 수정해야 한다.
- 코드가 여러 폴더에 분산되기 때문에 특정 기능에 대한 작업이 복잡해질 수 있다.
2. 레이어 간 의존성 문제
- 잘못 설계된 레이어 간 의존성은 전체 아키텍처를 복잡하게 만들고 유지보수를 어렵게 한다.
3. 각 레이어는 역할에 충실하도록 관리해야 한다.

출처 [code with andrea](https://codewithandrea.com/tutorials/) 